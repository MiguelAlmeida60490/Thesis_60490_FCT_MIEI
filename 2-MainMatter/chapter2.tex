%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{Conceitos}\label{cha:conceitos}

Este capítulo tem como objetivo apresentar os principais conceitos teóricos e técnicos que sustentam o desenvolvimento desta dissertação. São abordados os fundamentos relacionados com o processo de \textit{code review} no contexto do desenvolvimento de \textit{software}, bem como a evolução das abordagens de automação aplicadas a este processo.

\section{\textit{Code Review} no Desenvolvimento de \textit{Software}}

\textit{Code Review} é uma prática fundamental no desenvolvimento de software que consiste na análise sistemática do código-fonte por um ou mais programadores, com o objetivo de identificar defeitos, melhorar a qualidade do código e garantir a conformidade com boas práticas e padrões definidos pela organização~\cite{bacchelli2013expectations,rigby2013convergent}. Esta atividade é normalmente realizada antes da integração de alterações no ramo principal do projeto, assumindo um papel central nos fluxos de desenvolvimento modernos baseados em \textit{pull requests}.

Historicamente, a revisão de código surgiu como uma prática formal, associada a inspeções estruturadas, como as inspeções de Fagan, que demonstraram benefícios significativos na deteção precoce de erros e na redução de custos associados à correção de defeitos em fases avançadas do desenvolvimento~\cite{fagan1976design}. Com a evolução das metodologias ágeis e das plataformas colaborativas de desenvolvimento, a revisão de código tornou-se um processo mais leve e contínuo, integrado no ciclo diário de desenvolvimento de software~\cite{rigby2013convergent}.

Os principais objetivos da revisão de código incluem a deteção de erros lógicos e defeitos funcionais, a melhoria da legibilidade e manutenibilidade do código, a verificação da conformidade com padrões de estilo e boas práticas, bem como a mitigação de riscos relacionados com segurança e desempenho~\cite{mcintosh2014empirical}. Para além dos aspetos técnicos, a revisão de código desempenha também um papel relevante na partilha de conhecimento entre membros da equipa, promovendo a disseminação de boas práticas e contribuindo para a uniformização do código ao longo do projeto~\cite{bacchelli2013expectations}.

Apesar dos seus benefícios comprovados, a revisão de código é uma atividade exigente do ponto de vista cognitivo e temporal, dependendo fortemente da experiência e disponibilidade dos revisores. Em projetos de grande escala, caracterizados por elevados volumes de alterações e diversidade tecnológica, este processo pode tornar-se difícil de escalar, originando atrasos, inconsistências e variabilidade na qualidade das revisões realizadas~\cite{bacchelli2013expectations,mcintosh2014empirical}.

\section{Automação do Processo de \textit{Code Review}}

Com o aumento da complexidade dos sistemas de software e do volume de alterações submetidas diariamente, surgiu a necessidade de melhorar o processo de \textit{code review} através de mecanismos de automação. O principal objetivo destas abordagens é reduzir o esforço manual associado a tarefas repetitivas, melhorar a deteção precoce de defeitos e apoiar os revisores humanos na análise das alterações de código~\cite{bacchelli2013expectations}.

As primeiras tentativas de automação do \textit{Code Review} basearam-se essencialmente em ferramentas de análise estática de código. Estas ferramentas analisam o código-fonte sem necessidade de execução, recorrendo a regras pré-definidas para identificar problemas como violações de estilo, padrões perigosos, possíveis erros de execução ou más práticas comuns~\cite{liang2024automation}. Linters e analisadores estáticos tornaram-se parte integrante dos fluxos de desenvolvimento modernos, sendo frequerentemente integrados em pipelines de integração contínua.

Apesar dos benefícios associados à sua utilização, estas abordagens apresentam limitações significativas. Estudos mostram que ferramentas de análise estática tendem a gerar um elevado número de falsos positivos, o que pode levar à sua desvalorização por parte dos programadores~\cite{johnson2013donotuse}. Além disso, estas ferramentas possuem uma compreensão limitada do contexto em que o código é desenvolvido, não conseguindo capturar a intenção do programador, decisões de design ou requisitos específicos do domínio da aplicação~\cite{kim2016warnings}.

Outra limitação relevante prende-se com a rigidez das regras utilizadas. A adaptação destas ferramentas a práticas internas ou a estilos específicos de uma organização requer frequentemente configurações manuais complexas, dificultando a sua adoção em ambientes empresariais com grande diversidade tecnológica~\cite{liang2024automation}. Como consequência, a automação tradicional do \textit{code review} tende a ser eficaz na deteção de problemas simples e bem definidos, mas menos adequada para identificar defeitos mais complexos ou fornecer comentários contextualizados e acionáveis.

Estas limitações motivaram a investigação de abordagens mais avançadas para a automação do processo de revisão de código, explorando técnicas de aprendizagem automática capazes de aprender padrões diretamente a partir de grandes volumes de código-fonte e dados históricos de desenvolvimento~\cite{allamanis2018survey}. Estas abordagens abriram caminho para soluções mais flexíveis e contextuais, que serão discutidas nas secções seguintes.

\section{Aprendizagem Automática e \textit{Deep Learning} em \textit{Code Review}}

As limitações das abordagens tradicionais de automação do \textit{Code Review} motivaram a utilização de técnicas de aprendizagem automática e, posteriormente, de \textit{deep learning}. Ao contrário das ferramentas baseadas em regras fixas, estas abordagens permitem aprender padrões diretamente a partir de grandes volumes de código-fonte e dados históricos de desenvolvimento, reduzindo a necessidade de configuração manual e aumentando a capacidade de generalização~\cite{allamanis2018survey}.

Os primeiros trabalhos nesta área exploraram modelos estatísticos e técnicas de aprendizagem supervisionada para identificar padrões de defeitos, prever a probabilidade de erros e priorizar avisos gerados por ferramentas automáticas~\cite{kim2016warnings}. Estas abordagens demonstraram que informação histórica, como alterações anteriores e decisões tomadas em revisões passadas, pode ser utilizada para melhorar a eficácia do processo de revisão de código.

Com o avanço de técnias de \textit{deep learning}, surgiram modelos capazes de representar o código-fonte de forma mais expressiva, explorando a sua estrutura sintática e semântica. Trabalhos baseados em redes neuronais profundas passaram a utilizar representações como \textit{abstract syntax trees}, grafos de fluxo de controlo e sequências de \textit{tokens}, permitindo capturar relações mais complexas entre diferentes componentes do código base~\cite{tufano2019deeplearning}. Estes modelos mostram melhorias significativas em tarefas como deteção de defeitos, sugestões de correções e identificação de padrões recorrentes no código.

Outro avanço relevante foi a introdução do conceito de \textit{naturalness} do software, que assume que o código-fonte apresenta regularidades semelhantes às da linguagem natural. Estudos demonstraram que código que se desvia destes padrões tende a estar mais associado a defeitos, o que abriu caminho à aplicação de modelos de linguagem a análise de código~\cite{hindle2012naturalness}. Esta perspetiva reforçou a adequação de técnicas originalmente desenvolvidas para processamento de linguagem natural ao domínio do desenvolvimento de software.

Apesar dos progressos alcançados, as abordagens baseadas em Aprendizagem Automática e \textit{deep learning} apresentavam ainda algumas limitações práticas. Muitos modelos exigiam grandes volumes de dados rotulados, eram dispendiosos do ponto de vista computacional e apresentavam dificuldades em lidar com múltiplas linguagens de programação ou contextos organizacionais específicos~\cite{allamanis2018survey}. Além disso, a integração destas soluções nos fluxos de desenvolvimento reais permanecia um desafio.

Estas limitações criaram as condições para a adoção de modelos de linguagem de grande escala, capazes de aprender representações genéricas de código e de transferir conhecimento entre diferentes tarefas e linguagens. A utilização de \texorpdfstring{\gls{LLMs}}{LLMs} no processo de \textit{code review} será abordada na secção seguinte.

\section{Modelos de Linguagem de Grande Escala (\texorpdfstring{\gls{LLMs}}{LLMs})}

\section{\texorpdfstring{\gls{LLMs}}{LLMs} aplicados à Revisão de Código}

\section{Limitações atuais e Desafios}
